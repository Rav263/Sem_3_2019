RAII (resource acquisition os initialization)
resource release is destruction

Концепция конструкторов -- объект либо инициализированлибо не создан

Для статической переменной конструктор будет вызван при первом попадание в вызов


nullptr_t -- тип nullptr приводим к типу любого указателя


String::size -- квалификатор области видимости
::size -- Глобальная область видимости

Компилятор сам умеет генерировать конструкторы по умолчанию
String() = delete указание компилятору не генерировать конструктор по умолчанию

uniform initializer;
size_t size{100};

Деструкторы всега вызываются в обратном порядке к вызову конструкторов


Для объектов выделеных в динамической памяти нужно явно вызывать удаление

Конструктор копирования -- зло
String(const String &s) = delete Запрет конструктора копирования

Ссылка всегда инициализирована
const int & -- константная ссылка можно передавать значение

Список инициализации, перекрывает стандартную инициализацию
Поля должны идти по порядку, но могут быть опущен


String &operator =(const String &s) = delete -- Запретить оператор присваивания


Ключевое слово private: Всё что после к нему будут иметь доступ только методы класса
Если метод const то тогда ему первым параметром передаётся const String *this

Если метод не константный, то он не может быть применим к константным объектам

Действует integer promotion или convertion (менее приоритетный)

Любые convertion равнозначны, поэтому при возникновении неопределённости не компилируется

Преобразование типов c++ long(some); си (long) some

При l_value вызывается не константная ссылка, при значении, вызываеся константная ссылка

ЖОПА ГОРИТ ПОТУШИТЕ МОЮ ЖОПУ

Иерархия
1) Identity (const T&, T)
2) + const
3) promotion
4) conversion
5) user
6) ... ellipsis
7) ШАБЛНЫ И ИХ МАГИЯ СМОТРИТЕ ДАЛЕЕ
